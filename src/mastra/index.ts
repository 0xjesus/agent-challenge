// src/mastra/index.ts

import { Mastra } from "@mastra/core";
import { z } from "zod";
import { Octokit } from "@octokit/rest";
// --- ¡AQUÍ ESTÁ LA CORRECCIÓN! ---
// Apuntamos a la carpeta que SÍ existe.
import { readmeAgent } from "./agents/github-pr-monitor"; 

// Schema para el payload del evento "push"
const pushPayloadSchema = z.object({
  ref: z.string(),
  head_commit: z.object({
    message: z.string(),
  }).nullable(),
  repository: z.object({
    name: z.string(),
    owner: z.object({
      login: z.string(),
    }),
    default_branch: z.string(),
  }),
});

export const mastra = new Mastra({
  // Asegúrate que el agente que registras coincida con el que importas
  agents: { readmeAgent },
  server: {
    port: 8080,
    middleware: [
      async (c, next) => {
        if (c.req.method === 'POST' && c.req.path === '/api/github-webhook') {
          console.log('GitHub Push webhook received!');
          
          try {
            const payload = await c.req.json();
            const pushData = pushPayloadSchema.parse(payload);

            if (!pushData.head_commit) {
                return c.json({ status: 'skipped', reason: 'No head_commit found' });
            }

            if (pushData.head_commit.message.includes('[AI]')) {
              console.log('Push was from our AI bot. Skipping to prevent loop.');
              return c.json({ status: 'skipped', reason: 'AI commit' });
            }

            const defaultBranchRef = `refs/heads/${pushData.repository.default_branch}`;
            if (pushData.ref !== defaultBranchRef) {
              console.log(`Push was to branch ${pushData.ref}, not default branch. Skipping.`);
              return c.json({ status: 'skipped', reason: 'Not default branch' });
            }

            const owner = pushData.repository.owner.login;
            const repo = pushData.repository.name;
            console.log(`Push to default branch detected. Generating README for ${owner}/${repo}`);

            const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
            
            const { data: refData } = await octokit.git.getRef({ owner, repo, ref: defaultBranchRef });
            const { data: treeData } = await octokit.git.getTree({ owner, repo, tree_sha: refData.object.sha, recursive: 'true' });
            const fileList = treeData.tree.map(file => file.path).join('\n');

            const { data: packageJsonData } = await octokit.repos.getContent({ owner, repo, path: 'package.json' });
            const packageJsonContent = Buffer.from((packageJsonData as any).content, 'base64').toString('utf-8');

            const contentToAnalyze = `Project file structure:\n${fileList}\n\npackage.json content:\n${packageJsonContent}`;
            const agent = mastra.getAgent('readmeAgent');
            const response = await agent.generate([{ role: 'user', content: contentToAnalyze }]);
            const readmeContent = response.text;

            console.log('--- README.md content generated by AI ---');

            let existingFileSha: string | undefined;
            try {
              const { data: existingFileData } = await octokit.repos.getContent({ owner, repo, path: 'README.md' });
              existingFileSha = (existingFileData as any).sha;
            } catch (error: any) {
              if (error.status !== 404) throw error;
              console.log('README.md not found. Creating a new one.');
            }

            await octokit.repos.createOrUpdateFileContents({
              owner,
              repo,
              path: 'README.md',
              message: 'docs: [AI] Update README.md',
              content: Buffer.from(readmeContent).toString('base64'),
              sha: existingFileSha,
              committer: { name: 'AI README Bot', email: 'bot@nosana.io' },
              branch: pushData.repository.default_branch
            });

            console.log(`Successfully updated README.md in ${repo}.`);
            return c.json({ success: true, message: "README updated" });

          } catch (error) {
            console.error('Error processing push webhook:', error);
            return c.json({ success: false, error: 'Failed to process push' }, 500);
          }
        }
        await next();
      },
    ],
  },
});